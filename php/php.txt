方法：
	include_once和require_once的区别，前者包含或执行中遇错依然可以执行；后者则不执行
	isset($b) -判断变量$b是否存在
	json_encode($array) -数组编码
	serialize() --序列化
	unserialize() --反序列化
	__autoload() --自动加载类
		__autoload() 是专门为 类的不存在 而设计的！！！很多框架利用这个函数，实现 类文件的自动加载 ！！！
	
全局：
	global $c -声明变量c为全局可用
	session:
		session_start();//session开关，每个页面使用session前要加这么一句，也可以在全局设置
		$_SESSION['view']='你访问session了';

乱码解决：
	header('Content-Type: json; charset=utf-8'); //添加报头
	mysql_query("set names 'utf8'"); //添加到数据库内容乱码时

面向对象：
	__get(),__set() ：获取赋值属性。这两个方法不是默认存在的，是我们手工添加到类里的
	__isset(),__unset() ：检查和删除属性
		一般来说，类的属性通常是private,PHP5中预定义了__get(),__set()，__isset(),__unset()
		PS:set和get是专门为类的私有属性（private和protected）设立的，对于public是可以直接访问，即不走set和get函数！！！
	__toString()
		在类里面定义了“__toString()”方法，在直接输出对象引用的时候，自动调用 了”__toString()”方法， 输出“__toString()”方法中返回的字符，所以
		“__toString()”方法一定要有个返回值（return 语句）
	parent::
		使用：parent::__construct($cl);
			在子类中使用parent::的方式调用父类中被覆盖的方法
		还有一种方法Car::run()
			使用父类的“类名::“来调用父类中被覆盖的方法
	self::
	final关键字
		使用final关键标记的类不能被继承
		使用findl关键标记的方法不能被子类覆盖，是最终版本，比如连接数据库方法，不需要重写，那么就会用到final
	静态成员-static
		使用方法-类名::静态属性
	静态方法-static
		使用方法-类名::静态方法
	self::
		在方法中访问静态成员
	const关键字
	abstract关键字-定义抽象类
		抽象类里的方法都要在子类实现，不然子类还是抽象类
	interface接口
		接口是一种特殊的抽象类，里面所有方法都是抽象方法，所以接口不能产生实例对象；它也可以作为一种规范，所有抽象方法需要子类实现
	implements-
		我们定义接口的子类去实现全部抽象方法使用的关键字是implements,而不用extends
	PS:
		PHP是单继承的，一个类智能有一个父类，但是一个类可以实现多个接口
			class four implemtns 接口1，接口2，……
		PHP中不仅一个类可以实现多个接口，也可以在继承一个类的同时实现多个接口，一定要继承类再去实现接口
			class four extends 类名1 implemtns 接口1，接口2……

