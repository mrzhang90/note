vue是响应式的，当你在控制台通过app.data=XXX时，会自动调用set修改data属性值

##vant笔记
弹出提示，然后跳转页面
```js
    Dialog.alert({
        message: '弹出一段消息'
    }).then(() => {
        this.$router.push('address');
    });
```
##刷新当前页
``` js
router.push({
    //path:router.currentRoute.fullPath, // 获取当前连接，重新跳转
    path:route.fullPath, // 获取当前连接，重新跳转
    query:{
        _time:new Date().getTime()/1000 // 时间戳，刷新当前router
    }
})                    
    window.location.reload();
```

##锚点定位
```js
goTop(index){
    let anchor=this.$el.querySelector('#anchor'+index)
    if(document.documentElement.scrollTop>0){
        document.documentElement.scrollTop = anchor.offsetTop-100
    }else{
        document.body.scrollTop = anchor.offsetTop-100
    }
}
```
##动态生成海报活动图

html引入脚本
``` html
    <script src="../static/js/html2canvas.js"></script>
```
vue中直接调用，这里分两步
第一步.html2canvase把html布局转成canvas
第二步.把canvas转成img base64的海报图片
```js
    mounted() {
        //html布局转成canvas
        html2canvas(document.getElementById("to_canvas")).then((canvas)=>{
            this.showCanvas=true;
            // document.getElementById('canvas').appendChild(canvas);
            var ctx = canvas.getContext('2d');

            //canvas转base64图
            var dataImg = new Image()
            dataImg.src = canvas.toDataURL('image/png')
            document.getElementById('canvas').appendChild(dataImg) // 长按图片保存
        });
    }
```
参考：
[基于canvas生成图片](https://juejin.im/post/5aefc0456fb9a07abc29d36d)
### index.html里，head头部引入百度统计和CNZZ统计
```js
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9ed24a2995eecc14db7875b2d85560d6";

      var cz = document.createElement("script");
      cz.src = "https://s22.cnzz.com/z_stat.php?id=1274676836&web_id=1274676836";

      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
      s.parentNode.insertBefore(cz, s);
    })();
```

### 单页面加统计代码
在vue-router的beforeEach里，加入统计代码
```js
router.beforeEach((to, from, next) => {
    if (to.path) {
      _hmt.push(['_trackPageview', '/#' + to.fullPath]);
      if (window._czc) {
        window._czc.push(['_trackPageview', to.fullPath])
      }
    }
    next();
});
```
参考：
[百度统计开发平台](https://tongji.baidu.com/open/api/more?p=ref_trackPageview)
[CNZZ开发平台](https://developer.umeng.com/docs/67963/detail/73619)
##scroll-滚动导航定位
    定义navigator组件
        页面滚动时导航浮动定位
        页面滚动时，给导航链接添加样式
    点击导航，页面滚动到相应位置
1. 创建navigator.vue组件
    ```html
    <template>
    <div class="navigate_warp h190">
            <ul id="navigate" class="navigate w690 h190 auto br20 flex f30 cg3 b" :class="{fixedScroll:isfixedScroll}">
                <li class="j_nav_li flex1 nav_li flex l_center v_center" @click="goTop(1)">
                    <span v-show="isfixedScroll">课程导学</span>
                </li>
                <li class="j_nav_li flex1 nav_li flex l_center v_center" @click="goTop(2)">
                    <span v-show="isfixedScroll">亲子共学</span>
                </li>
                <li class="j_nav_li flex1 nav_li flex l_center v_center" @click="goTop(3)">
                    <span v-show="isfixedScroll">学习打卡</span>
                </li>
            </ul>
        </div>
    </template>
    ```
    ```js
    <script>
    import _throttle from 'lodash/throttle'
    export default {
        // 获取元素-课程导学、亲子共学、学习打卡
        props:['course_el'],
        data(){
            return {
                // 存储scroll绑定的事件-页面卸载时需要
                scrollFn:null,
                // 存储导航元素
                navigateEle:null,
                // 导航是否固定定位
                isfixedScroll:false,
                position: {scrollTop: 0, scrollLeft: 0},
            }
        },
        mounted(){
            this.navigateEle=this.$el.querySelector('#navigate');
            this.position.scrollTop=this.navigateEle.offsetTop;
            this.position.height=this.navigateEle.clientHeight;
            // 存储scroll绑定的事件-页面卸载时需要
            this.scrollFn=_throttle(this.onScroll,300)
            // 节流-一定间隔时间内调用，使用鼠标滚动
            window.addEventListener('scroll',this.scrollFn)
        },
        methods:{
            // scroll事件绑定
            onScroll(e){
                // console.log(this.course_el)
                let _top=(document.documentElement.scrollTop || document.body.scrollTop);
                // 导航距顶部距离
                if(this.position.scrollTop <= _top){
                    // 导航贴上顶部了，导航浮动
                    this.isfixedScroll=true;
                    // 导航贴上顶部了，那么很快就会进入三大块的区域了
                    for(let item of this.course_el){
                        if(item.top <= _top+this.position.height+100){
                            // 通知父级-当前索引的导航要添加active样式
                            this.$emit('navActive',item.index);
                            break;
                        }
                    }
                }else{
                    // 导航距顶部还有空间,选中的样式删除-通知父级
                    this.$emit('navActive',-1);
                    // 导航距顶部还有空间，导航取消浮动
                    this.isfixedScroll=false;
                    return;
                }
                
            },
            // 页面离开-卸载scroll-父组件通知
            unbind(){
                window.removeEventListener('scroll',this.scrollFn);
            },
            // 锚点跳转
            goTop(index){
                this.$emit('goTop',index)
            }
        }
    }
    </script>
    ```
    ```css
    <style lang="less" scoped>
    @file_path:"../../assets";
    @import "@{file_path}/css/util.less";
    // 这个元素是用来占位的，等.navigate类添加fixed定位后，这里占位还在，页面就不会晃动
    .navigate_warp{
        .navigate{
            // background-color:#ffffff;
            .bgImg("@{file_path}/images/day5/navigate.png",0 0);
            box-shadow: 0px 0px 14px 2px rgba(18, 181, 216, 0.42);
            &.fixedScroll{
                height:90px;
                position: fixed;top:10px;left:50%;z-index:9;
                transform:translateX(-50%);
                background-image: linear-gradient(-45deg, 
                #fdffff 0%, 
                #ffffff 100%);
            }
            li{
                position: relative;
                &:before{
                    content:"";
                    position:absolute;left:50%;bottom:0;
                    transform:translateX(-50%);
                    width: 0;
                    height: 7px;
                    border-radius: 40px;
                    background-image: linear-gradient(90deg, 
                    #f7c313 0%, 
                    #fe8501 100%);
                }
                &.active{
                    // color: #215fff;
                    color: #fe8501;
                    &:before{
                        width: 139px;
                        transition: .6s;
                    }
                }
            }
        }
    }
    </style>
    ```
1. 父组件
    1. 引用
        ```js
        import Navigator from "../../components/day5/navigate";
        components:{
            // 导航
            Navigator,
        }
        ```
    1. 使用
        ```html
        <Navigator ref="navigate" :course_el="course_el" @navActive="navActive" @goTop="goTop"></Navigator>
        ```
        ```js
        data(){
            // 获取元素-课程导学、亲子共学、学习打卡
            this.course_el=null;
        }
        mounted(){
            // 获取元素-课程导学、亲子共学、学习打卡
            this.course_el=[
                {
                    'index':2,
                    'el':document.getElementById('anchor3'),
                    'top':document.getElementById('anchor3').offsetTop,
                },
                {
                    'index':1,
                    'el':document.getElementById('anchor2'),
                    'top':document.getElementById('anchor2').offsetTop,
                },
                {
                    'index':0,
                    'el':document.getElementById('anchor1'),
                    'top':document.getElementById('anchor1').offsetTop,
                },
            ]
        }
        // 组件内的路由守卫-路由离开时触发
        // 替代destory生命周期
        beforeRouteLeave(to, from, next){
            // 页面要离开时，通知navigator组件，卸载scroll事件
            this.$refs.navigate.unbind();
            next();
        },
        menthods:{
            navActive(index){
                let _c_el=this.$el.querySelectorAll('.j_nav_li');
                // 返回顶部时，导航距顶部还有空间时
                for(let i=0;i<3;i++){
                    if(i==index){
                        addClass(_c_el[index],'active');
                    }else{
                        removeClass(_c_el[i],'active');
                    }
                }
            },
            // 锚点跳转
            goTop(index){
                let anchor=this.$el.querySelector('#anchor'+index)
                // 先跳一下，因为top为0时，if肯定阶段走不到，但else兼容有问题，就歇菜了
                // 所以我先跳一下，如果if兼容性没问题，那么就肯定走if了，或者必然走else
                document.documentElement.scrollTop=1;
                // 兼容性判断，如果if不兼容，就走else
                if(document.documentElement.scrollTop>0){
                    document.documentElement.scrollTop = anchor.offsetTop-100
                }else{
                    document.body.scrollTop = anchor.offsetTop-100
                }
            },
        }
        ```