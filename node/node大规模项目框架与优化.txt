压力测试
	可以测试内存泄露的问题

Nginx
	pm2->rqequrst

异步IO
	前端通过异步IO可以消除UI堵塞

IO是昂贵的，分布式IO更昂贵
	理解分布式IO，比如前后端分离，你从java分布器访问前端脚本服务器，那么用户先通过网络请求java服务器，在通过网络请求前端服务器，还要读取硬盘脚本文件，那么这些所占用的时间相对于本地是非常长的
node适用于IO密集型，不适用CPU密集型
	node适合IO密集型，不管来多少请求，都能全部接收，但不是同时返回，它再等，等一个完成就吐出一个，再处理一个再吐出一个
		一起进，不一起出
	反之，例如银行存款，你存钱或者取钱都会产生利息手续费，那么需要紧急运算，所以不适合IO密集型，而适合CPU密集型

底层知识
CPU时钟周期：
	1/CPU主频 -> 1/2.5GHZ
	CPU主频越大，得到的值越小，那么CPU处理速度越快

不是说系统去同步或者全异步就好，只有同步和异步达到一定比例，那么系统才是最高效的

v8不支持ES6，node支持ES6

完美的异步IO应该是应用程序发起非阻塞调用，无需通过遍历或者事件循环等方式
LIBUV ！！！
	帮助事件轮询-通知机制
LIBUV在linux下叫做custom threadpool,在window下叫做iocp
帮助事件轮询的libuv 和 库v8不是一个线程


函数式编程在Node中的应用
	高阶函数：可以将函数作为输入或者返回值，形成一种后续传递风格的结果接受方式，而非单一的返回值形式。后续传递风格的程序将函数业务重点从返回值传递到回调函数中。
	app.use(function(res,req){//todo});
		你使用use函数，把函数返回值传到use的fn参数里，这种风格叫做后续传递风格
	偏函数：指定部分参数产生一个新的定制函数的形式就是偏函数。Node中异步编程非常常见，我们通过哨兵变量会很容易造成业务的混乱。underscore,after变量

V8垃圾回收机制
	Node使用javascript在服务端操作大内存对象收到了一定的限制，64位系统下大约为1.4GB，32操作系统下是0.7GB
	V8垃圾回收策略主要基于分代式垃圾回收机制。在自动垃圾回收的演变过程中，人们发现没有一种垃圾回收算法能够胜任所有场景。V8中内存分为新生代和老生代两代。
	新生代为存活时间较短对象，老生代中为存活时间较长的对象！！！！
		闭包函数会被存到老生代，赋值为null则存到新生代
	了解Scavenge算法

服务器集群