<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    console.log('WeakSet结构与Set类似，也是不重复的值的集合。' +
        '它与Set有两个区别。1.WeakSet的成员只能是对象，而不能是其他类型的值。' +
        '2.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。');
    var ws=new WeakSet();
//    ws.add(1);//Uncaught TypeError: Invalid value used in weak set
//    wx.add(Symbol)//Uncaught TypeError: Invalid value used in weak set
    console.log('上面代码报错，因为它只能放对象');
    var a=[[1,2],[3,4]];
    var ws=new WeakSet(a);
    console.log(ws)//WeakSet {[1, 2], [3, 4]}
    console.log('上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为WeakSet构造函数的参数，a的成员会自动成为WeakSet的成员。注意，是a数组的成员成为WeakSet的成员，而不是a数组本身。这意味着，数组的成员只能是对象。')
    var b=[1,2];
//    var ws=new WeakSet(b);//Uncaught TypeError: Invalid value used in weak set
    console.log('上面代码中，数组b的成员不是对象，加入WeaKSet就会报错。')

    console.log('\nWeakSet结构有以下三个方法。' +
        'WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。' +
        'WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。' +
        'WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。')
    var obj={};
    var ws=new WeakSet();
    ws.add(window);
    ws.add(obj);
    console.log(ws.has(window))//true
    console.log(ws.has(obj))//true
    ws.delete(window)
    console.log(ws.has(window))//false
    ws.delete(obj)
    console.log(ws.has(obj))//false
    console.log('WeakSet没有size属性，没有办法遍历它的成员。')
    console.log(ws.size)//undefined
    console.log(ws.forEach)//undefined
    console.log('WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。')
    console.log('WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。')
    const foos=new WeakSet();
    var arr=[];
    class Foo{
        constructor(){
            arr.push(1)
            foos.add(this)
        }
        methodArr(){
            if(arr.length<0){
                throw new Error('数组没有数据')
            }
            return arr
        }
        methodWeak(){
            if(!foos.has(this)){
                throw new Error('Foo.prototype.method 只能在Foo的实例上调用！');
            }
            return foos
        }
    }
    var f=new Foo();
    console.log(f.methodArr())//[1]
    console.log(f.methodWeak())//WeakSet {Foo {}}
    console.log('上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用WeakSet的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。')
</script>
</body>
</html>