来源：http://blog.csdn.net/zhangzhifei1991/article/details/50290393
来源：http://blog.csdn.net/ImagineCode/article/details/50863972

重排和重绘
	网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。
	以下三种情况，会导致网页重新渲染。
		1.修改DOM
		2.修改样式表
		3.用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）
	重新渲染，就需要重新生成布局和重新绘制。前者叫做"重排"（reflow），后者叫做"重绘"（repaint）。
	需要注意的是，"重绘"不一定需要"重排"，比如改变某个网页元素的颜色，就只会触发"重绘"，不会触发"重排"，因为布局没有改变。但是，"重排"必然导致"重绘"，比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了。

提高性能的九个技巧
	有一些技巧，可以降低浏览器重新渲染的频率和成本。
	第一条是上一节说到的，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。
	第二条，缓存重排结果。
		如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。
	第三条，统一改样式。
		不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。
	第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。
		比如，操作Document Fragment对象，完成后再把这个对象加入DOM。
		再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。
	第五条，先将元素设为 display: none （需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。
	第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。
	第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden 的元素只对重排有影响，不影响重绘。
	第八条，使用虚拟DOM的脚本库，比如React等。
	第九条，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染（详见后文）。

提高性能
	重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。
	提高网页性能，就是要降低"重排"和"重绘"的频率和成本，尽量少触发重新渲染。
	前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。
	一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。
		offsetTop/offsetLeft/offsetWidth/offsetHeight
		scrollTop/scrollLeft/scrollWidth/scrollHeight
		clientTop/clientLeft/clientWidth/clientHeight
		getComputedStyle()
		所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。
	一般的规则是：
		样式表越简单，重排和重绘就越快。
		重排和重绘的DOM元素层级越高，成本就越高。
		table元素的重排和重绘成本，要高于div元素
		尽量不要把读操作和写操作，放在一个语句里面

网页是如何渲染的?
	（1）获取DOM并将其分割为多个层（联想到：photoshop中的分层）；
	（2）将每个层独立的绘制进位图中；
	（3）将层作为纹理上传至GPU；（层在GPU中如果不变，也会缓存）
	（4）复合多个层来生成最终的屏幕图像。

	具体过程：
	（1）DOM子树渲染层（RenderLayer）–(对应)->RenderObject–(对应)->GraphicsContext(根元素、position、transform、半透明、CSS滤镜、Canvas2D、video、溢出，这些都会产生层，这些发生在CPU中)

	如果需要GPU参与，则需要如下合成：

	（2）（正常渲染，写一遍画一遍）Compositor->渲染层子树的图形层（GraphicsLayer）–>RenderLayer–>RenderObject
	Compositor将所有的拥有compositing layer进行合成，合成过程GPU进行参与。合成完毕就能够将纹理映射到一个网格几何结构之上——在视频游戏或者CAD程序中，这种技术用来给框架式的3D模型添加“皮肤”。Chrome采用纹理把页面中的内容分块发送给GPU。纹理能够以很低的代价映射到不同的位置，而且还能够以很低的代价通过把它们应用到一个非常简单的矩形网格中进行变形。这就是3D CSS的实现原理啦。
	（能够触发合层的：CSS 3D透视变换、video、webGL、transform动画、加速CSS滤镜、叠加在已经触发合成层，这些发生在GPU中）