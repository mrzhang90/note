v8内置即时编译引擎

页面看到的元素(input等所有html元素)都属于render引擎，也就是针对DOM树,DOM元素
在这个页面背后有一个js脚本，
js和render沟通需要成本，同时他们为了保证一致性，例如用户点击提交时，js要用户点击执行过程中没有改变输入。
所以js使用单线程，牺牲了一些性能，达到一致性，所以不要执行过长的脚本

闭包：
	传统下，函数内变量声明，函数执行完毕，变量清除
	闭包下，例如setTimeout或者callback内，变量一缕就可以缕到很早之前的变量(甚至跟节点)，所以闭包内变量声明周期会被延长，现在的编译器也做了性能优化，只保留用到的变量，但还是会有一定的性能问题
	例如：
		执行一万次甚至十万次的循环，页面会有卡住的情况，
		那么解决方式是，把循环拆成10个小一点的循环，每个循环用setTimeout执行下一个，
		思路是每次执行后释放出当前执行的栈，然后让UI响应

页面我们叫他盒子，
	如果盒子周围的盒子发生长宽度变化，就会其他的盒子，触发reflow-重排
	如果只是盒子内部发生变化，那么只会重排这一块

Google AMP：
	目的为了让页面最短的时间内打开
	方向是资讯类页面
	能力：
		减少请求数
		减小体积
		牺牲一部分UE
		牺牲一部分开发效率
	为什么用
		图片占用网络的请求，
			所以不用默认img从而控制加载时机
		图片的大小未知，会触发reflow
			所以强制要求图片必须在渲染前指定大小
		类似的还有
			amp-video
			amp-iframe
			amp-audio
			.etc
	他怎么做的
		页面加载它先加载标签里的图片，等真正加载之后，它才继续往后加载
	AMP CSS:
		所以的css
			必须inline
			必须在head
			只能有一个
			禁止 Inline style
			禁止 !important
			禁止 *selector
			禁止 filter
		为什么这样限制
			不发额外请求
			body渲染前所有的样式都已经定义完
			避免多次rerender
			保证AMP对页面的控制
			控制会造成渲染引擎性能问题的属性
		其他组件-帮你把组件做到最优，不用也可参考
			动态列表、轮播、遮罩、第三方播放器、社交媒体播放器
	AMP的限制
		只允许async脚本
		显示指定UI尺寸
			避免使用大量计算的方式
		CSS只能有一个inline
		CSS只能50k
		允许有限的css动画
		控制资源加载，动画执行
	AMP的原则
		严格控制外部资源
		严格控制整个页面渲染
		严格控制CSS动画
自由即奴役
	https://zhuanlan.zhihu.com/p/21741712
	AMP做的太好，性能就好很多，但是页面效果差一些，开发成本高一些