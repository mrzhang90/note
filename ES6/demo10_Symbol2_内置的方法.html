<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    console.log('Symbol.for接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。');
    var s1=Symbol.for('ceshi');
    var s2=Symbol.for('ceshi');
    console.log(s1==s2)//true
    console.log('上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。');
    console.log('Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。');
    console.log('Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。');
    var s3=Symbol.for('ceshi');
    console.log(Symbol.keyFor(s3))//ceshi
    var s4=Symbol('ceshi');
    console.log(Symbol.keyFor(s4));//undefined

    console.log('\n除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。');
    console.log('对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。');
    class myClass{
        [Symbol.hasInstance](foo){
            console.log(foo instanceof Array)
            return foo instanceof Array;
        }
    }
    [1,2,3] instanceof new myClass()
    class Even{
        static [Symbol.hasInstance](obj){
            console.log(obj%2===0)
        }
    }
    1 instanceof Even;
    2 instanceof Even;
    4 instanceof Even;

    console.log('对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开。');
    var arr1=['a','b'];
    ['c','d'].concat(arr1,'e');//["c", "d", "a", "b", "e"]
    console.log(arr1[Symbol.isConcatSpreadable]);//undefined
    var arr2=['a','b'];
    arr2[Symbol.isConcatSpreadable]=false;
    console.log(['c','d'].concat(arr2,'e'));//["c", "d", ['a','b'], "e"]
    console.log('上面代码说明，数组的默认行为是可以展开。Symbol.isConcatSpreadable属性等于true或undefined，都有这个效果。')
    console.log('下面代码发现，类似数组的对象也可以展开，但它的Symbol.isConcatSpreadable属性默认为false，必须手动打开。')
    var obj={length:2,0:'c',1:'d'};
    console.log(['a','b'].concat(obj,'e'));//["a", "b", Object, "e"]
    obj[Symbol.isConcatSpreadable]=true;
    console.log(['a','b'].concat(obj,'e'));//["a", "b", "c", "d", "e"]
    console.log('对于一个类来说，Symbol.isConcatSpreadable属性必须写成实例的属性。类A1是可展开的，类A2是不可展开的，所以使用concat时有不一样的结果。')
    class A1 extends Array{
        constructor(args){
            super(args);
            this[Symbol.isConcatSpreadable]=true;
        }
    }
    class A2 extends Array{
        constructor(args){
            super(args);
            this[Symbol.isConcatSpreadable]=false;
        }
    }
    var a1=new A1();
    a1[0]=4;
    a1[1]=5;
    var a2=new A2();
    a2[0]=6;
    a2[1]=7;
    console.log([1,2,3].concat(a1,a2))//[1, 2, 3, 4, 5, [6,7]]
</script>
</body>
</html>